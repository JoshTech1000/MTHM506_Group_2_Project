
\section{Appendix}

\subsection{Figures}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/pearson_correl.jpg}
\caption{\label{fig:pearson_correl}Correlogram shows covariates with highest positive and negative correlations.}
\end{figure}

\subsection{Tables}

\begin{table}[H]
\centering
\begin{tabular}{l|r}
Item & Quantity \\\hline
Widgets & 42 \\
Gadgets & 13
\end{tabular}
\caption{\label{tab:widgets}An example table.}
\end{table}

\subsection{Code}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]{R}
#####################SS CODE######################
# Import Libraries
library(mgcv) # required for GAM 
library(tidyverse) 
library(ggplot2) # required for plotting
library(dplyr) # required for filtering dataset
library(fields) # required for maps
library(maps) # required for maps
library(reshape2) # only required for melt in corr plot
library(car) # only required for VIF

# Load Data
load("C:/Users/soura/Documents/COMM511/group_coursework/datasets_project.RData")

# Investigate correlation
### Resource -> http://www.sthda.com/english/wiki/ggplot2-quick-
### correlation-matrix-heatmap-r-software-and-data-visualization
cormat <- cor(TBdata[,c(1,2,3,4,5,6,7,8)])
# Reorder
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

# Reorder the correlation matrix
cormat <- reorder_cormat(cormat)
# Get lower triangular matrix
cormat[lower.tri(cormat)] <- NA

melted_cormat <- melt(cormat , na.rm = TRUE)
melted_cormat$value = round(melted_cormat$value, 2)

# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "#1a85d6", high = "#cf3e4f", mid = "white", 
midpoint = 0, limit = c(-1,1), space = "Lab", 
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 90, vjust = 1, 
size = 12, hjust = 1))+
coord_fixed()

# Add correlation coefficients
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 2) +
theme(
axis.text.x = element_text(size = 6),
axis.text.y = element_text(size = 6),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal",
legend.text = element_text(size = 6)
) + 
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))

#### Illiteracy is highly correlated with Poverty
#### Carry out a Variance Inflation Test
model_all <- lm(TB ~ . , data = select(TBdata, 'Indigenous' , 'Illiteracy' , 
'Urbanisation' , 'Density' , 'Poverty', 'Unemployment' , 'Timeliness' , 'Year' ,
'TB' , 'Population'))  # with all the independent variables

vif(model_all) # Several variables are highly correlated

model_no_illiteracy <- lm(TB ~ . , data = select(TBdata, 'Indigenous', 
'Urbanisation' , 'Density' , 'Poverty', 'Unemployment' , 'Timeliness' , 'Year' ,
'TB' , 'Population'))  # with all the independent variables

vif(model_no_illiteracy) # Poverty and Unemployment still seem highly correlated

model_no_illiteracy_no_poverty <- lm(TB ~ . , data = select(TBdata, 'Indigenous', 
'Urbanisation' , 'Density', 'Unemployment' , 'Timeliness' , 'Year' ,
'TB' , 'Population'))  # with all the independent variables

vif(model_no_illiteracy_no_poverty) # almost no variable is highly correlated

## More formal tests are conducted to confirm the dropping of Illiteracy.
## Check to see if Poverty should be dropped as well
prelim.model.1 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) + 
s(Illiteracy) + s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation)
+ s(Unemployment) + s(Timeliness),
data = TBdata , 
family = nb(link = 'log')
)
# Show summary
summary(prelim.model.1)
par(mfrow=c(2,2))
gam.check(prelim.model.1)

### Only the effect of illiteracy cannot be reliably stated to be non-zero
prelim.model.2 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation)
+ s(Unemployment) + s(Timeliness),
data = TBdata , 
family = nb(link = 'log')
)
# Show summary
summary(prelim.model.2)

# Show summary
summary(prelim.model.2)
par(mfrow=c(2,2))
gam.check(prelim.model.2)

# Likelihood ratio test
anova(prelim.model.1 , prelim.model.2 , test = 'F') # p-value is over 0.05
# The models are statistically indistinguishable

### Only the effect of illiteracy cannot be reliably stated to be non-zero
prelim.model.3 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) 
+ s(Timeliness),
data = TBdata , 
family = nb(link = 'log')
)
# Show summary
summary(prelim.model.3)

# Likelihood ratio test
anova(prelim.model.2 , prelim.model.3 , test = 'F') # p-value is less than 0.05
# The models are statistically different. Poverty should not be excluded.

### Model chosen (with social covariates) is the negative binomial without
### Illiteracy
summary(prelim.model.2) # Only 44% of the deviance is explained. Adding temporal
# and spatial covariates may improve this
par(mfrow=c(2,2))
gam.check(prelim.model.2)
par(mfrow = c(1,1))

### Only the effect of illiteracy cannot be reliably stated to be non-zero
prelim.model.4 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous , k = 20) 
+ s(Urbanisation , k = 20) + s(Density , k = 20) + s(Poverty , k = 20)
+ s(Poor_Sanitation , k = 20) + s(Unemployment , k = 20) + s(Timeliness , k = 20),
data = TBdata , 
family = nb(link = 'log')
)
# Show summary
summary(prelim.model.4)
par(mfrow=c(2,2))
gam.check(prelim.model.4)


### Adding spatial covariates
spatial.model <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) +s(Poverty)
+ s(Timeliness) + s(lon , lat),
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(spatial.model)
# Check the smooth functions of the covars
plot(spatial.model)
par(mfrow=c(2,2))
gam.check(spatial.model)
par(mfrow = c(1,1))
spatial.model$aic

### Using separate smoothers
spatial.model.2 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + te(lon , lat , k = 20),
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(spatial.model.2)
# Check the smooth functions of the covariates
plot(spatial.model.2)
par(mfrow=c(2,2))
gam.check(spatial.model.2 , pch = 20)
par(mfrow = c(1,1))

### PREDICTIONS
fitted_nb <- predict(spatial.model.2, newdata = TBdata , type = 'response')

# PLOTTING STUFF - ERROR WHILE COMPILING - WILL FIX LATER
par(mfrow = c(1,1))
plot.map(exp(log(fitted_nb) - log(TBdata$Population))*100000 , n.levels = 10)


TBdata$Year.asFactor <- factor(TBdata$Year)

#### Temporal covariates
temporal.model <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + Year.asFactor,
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(temporal.model) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(temporal.model)
par(mfrow=c(2,2))
gam.check(temporal.model)
par(mfrow = c(1,1))

#### Temporal covariates
temporal.model.2 <- gam(formula = TB ~ offset(log(Population))
+ s(Indigenous , by=Year.asFactor) + s(Urbanisation , by=Year.asFactor)
+ s(Density , by=Year.asFactor) + s(Poor_Sanitation , by=Year.asFactor)
+ s(Unemployment , by=Year.asFactor) + s(Poverty , by=Year.asFactor)
+ s(Timeliness , by=Year.asFactor) , 
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(temporal.model.2) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(temporal.model.2)
par(mfrow=c(2,2))
gam.check(temporal.model.2)
par(mfrow = c(1,1))

### Spatio-temporal model
spatio.temporal.model <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + te(lon , lat , k = 20) + Year.asFactor,
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(spatio.temporal.model) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(spatio.temporal.model)
par(mfrow=c(2,2))
gam.check(spatio.temporal.model , pch = 20)
par(mfrow = c(1,1))

# PLOT
fitted_nb <- predict(spatio.temporal.model, newdata = TBdata , type = 'response')
TBdata$pred_rate <- fitted_nb/TBdata$Population*100000

# PLOTTING STUFF - ERROR WHILE COMPILING - WILL FIX LATER
par(mfrow = c(1,1))
plot.map(TBdata$pred_rate , n.levels = 10)

### WIHTOUT POVERTY
### Spatio-temporal model - Poverty
spatio.temporal.model.wo.pov <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment)
+ s(Timeliness) + te(lon , lat , k = 20) + Year.asFactor,
data = TBdata , 
family = nb(link = 'log')
)

# Check summary
summary(spatio.temporal.model.wo.pov) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(spatio.temporal.model.wo.pov)
par(mfrow=c(2,2))
gam.check(spatio.temporal.model.wo.pov , pch = 20)
par(mfrow = c(1,1))

# Anova test
anova(spatio.temporal.model.wo.pov , spatio.temporal.model , test = 'F')

### Without Indigenous
spatio.temporal.model.wo.indig <- gam(formula = TB ~ offset(log(Population))
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + te(lon , lat , k = 20) + Year.asFactor,
data = TBdata , 
family = nb(link = 'log')
)

# Check summary
summary(spatio.temporal.model.wo.indig) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(spatio.temporal.model.wo.indig)
par(mfrow=c(2,2))
gam.check(spatio.temporal.model.wo.indig , pch = 20)
par(mfrow = c(1,1))

# Anova test
anova(spatio.temporal.model.wo.indig , spatio.temporal.model , test = 'F')
# NOT ENOUGH EVIDENCE TO REMOVE INDIGENOUS

## Spatio-temporal model
spatio.temporal.model.true <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) 
+ s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + te(lon , lat , Year , k = 3),
data = TBdata , 
family = nb(link = 'log')
)

# Check summary
summary(spatio.temporal.model.true) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(spatio.temporal.model.true)
par(mfrow=c(2,2))
gam.check(spatio.temporal.model.true , pch = 20)
par(mfrow = c(1,1))

spatio.temporal.model$aic
spatio.temporal.model.true$aic
spatio.temporal.model.wo.indig$aic



### Spatio-temporal model - no poor sanitation , indigenous
spatio.temporal.model.wo.indig.poor_s <- gam(formula = TB ~ offset(log(Population))
+ s(Urbanisation) + s(Density) + s(Unemployment) + s(Poverty)
+ s(Timeliness) + te(lon , lat , k = 20) + Year.asFactor,
data = TBdata , 
family = nb(link = 'log')
)
# Check summary
summary(spatio.temporal.model.wo.indig.poor_s) # Temporal alone doesn't add much to explaining the variance
# Check the smooth functions of the covariates
plot(spatio.temporal.model.wo.indig.poor_s)
par(mfrow=c(2,2))
gam.check(spatio.temporal.model.wo.indig.poor_s , pch = 20)
par(mfrow = c(1,1))

anova(spatio.temporal.model , spatio.temporal.model.wo.indig.poor_s , spatio.temporal.model.wo.indig , test = 'F')

################LH CODE############################################
library (mgcv)


par(mfrow = c(2,2))
#fit poisson model with socio-economic variables
model_poisson <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) +  s(Illiteracy) +  s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation) + s(Unemployment) + s(Timeliness), data = TBdata, family = poisson(link = 'log'))
summary(model_poisson)
model_poisson$aic
par(mfrow = c(2,2),pch = 20)
gam.check(model_poisson)
# #add flexibility
model_poisson <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous, k = 80) +  s(Illiteracy, k = 80) +  s(Urbanisation, k = 80) + s(Density, k = 80) + s(Poverty, k = 80) + s(Poor_Sanitation, k = 80) + s(Unemployment, k = 80) + s(Timeliness, k = 80), data = TBdata, family = poisson(link = 'log'))
gam.check(model_poisson)
summary(model_poisson) # SIGNS OF OVERFIT
plot(model_poisson) # SIGNS OF OVERFIT
#fit negative binomial model with  socioeconomic
model_nb <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) +  s(Illiteracy) + s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation) + s(Unemployment) + s(Timeliness), data = TBdata, family = nb(link = 'log'))
summary(model_nb)
model_nb$aic
#fit a linear relation between sqaured residuals and prediction to see whether another model describes the variance-fitted values relation better
summary(lm(log(model_nb$residuals^2) ~ log(predict(model_nb, type = 'response'))))
#drop Illiteracy
model_nb_2 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) +  s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation) + s(Unemployment) + s(Timeliness), data = TBdata, family = nb(link = 'log'))


#LRT
anova.gam(model_nb_2, model_nb, test = 'LRT')
#Null hypothesis not rejected -> drop poverty
model_nb_3 <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) +  s(Urbanisation) + s(Density) + s(Poor_Sanitation) + s(Unemployment) + s(Timeliness), data = TBdata, family = nb(link = 'log'))
#LRT
anova.gam(model_nb_3, model_nb_2, test = 'LRT')
# NULL hypothesis rejected -> drop only illiteracy, not poverty

model_nb_final <- model_nb_2
summary(model_nb_final)
gam.check(model_nb_final)
fitted_nb <- predict(model_nb_final, type = 'response')

# PLOTTING STUFF - ERROR WHILE COMPILING - WILL FIX LATER
par(mfrow = c(1,2))
plot.map(log(fitted_nb) - log(TBdata$Population) , n.levels = 10)
plot.map(log(TBdata$TB) - log(TBdata$Population))

#temporal model
par(mfrow = c(2,2), pch = 20)
model_nb_time <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous, by = Year) + s(Urbanisation, by = Year) + s(Density, by = Year) + s(Poverty, by = Year) + s(Poor_Sanitation, by = Year) + s(Unemployment, by = Year) + s(Timeliness, by = Year), data = TBdata, family = nb(link = 'log'))
summary(model_nb)
model_nb$aic

#spatial model
model_nb_space <- gam(formula = TB ~ offset(log(Population)) + s(Indigenous) + s(Urbanisation) + s(Density) + s(Poverty) + s(Poor_Sanitation) + s(Unemployment) + s(Timeliness) + te(lon, lat), data = TBdata, family = nb(link = 'log'))
summary(model_nb_space)
model_nb_space$aic
gam.check(model_nb_space)
anova.gam(model_nb_space, model_nb_final, test = 'LRT')

#spatio-temporal model
model_nb_time_and_space <- gam(formula = TB ~ offset(log(Population)) + s(Urbanisation, by = Year) + s(Density, by = Year) + s(Poverty, by = Year) + s(Poor_Sanitation, by = Year) + s(Timeliness, by = Year) + s(Unemployment, by = Year) + te(lon,lat, by = Year), data = TBdata, family = nb(link = 'log'))
summary(model_nb_time_and_space)
model_nb_time_and_space$aic
gam.check(model_nb_time_and_space)

# PLOT
fitted_nb <- predict(model_nb_time_and_space, newdata = TBdata , type = 'response')

# PLOTTING STUFF - ERROR WHILE COMPILING - WILL FIX LATER
par(mfrow = c(1,1))
plot.map(exp(log(fitted_nb) - log(TBdata$Population))*100000 , n.levels = 10)
\end{minted}